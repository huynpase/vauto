==Why do we need a Framework for Automation?==
_Whether its the god's bony creatures or its a human made buildings, nothing can stand erect and achieve the heights without a framework. Our skeleton may not be performing specific tasks like most of the vital organs do, still it plays the most important role by supporting the organs to do their tasks at the best. On the other hand a house with no pillars can not with stand the natures calamities. Whether its a physical object or a software, there is a need of framework to support individual components doing their specific job._<br/>

Many automation tools are available in market. Some for web automation, some for windows, some specific for database and so on. But these tools individually can not with stand diverse requirements. We need some unified framework which can help these tools to bring a collaborative effort to attain the height of success.

Lets realize the need in detail:<br/>
===Tools incapability:===
Automation tool vendors do not provide complete forthright demonstrations when showcasing the "simplicity" of their tools. We have seen the vendor’s sample applications. We have seen the tools play nice with those applications. And we try to get the tools to play nice with our applications just as fluently. Inherently, project after project, we do not achieve the same level of success. Here we are left with two options. Either do we switch to the new tool or mastermind technically creative solutions to make these automation tools work with our applications. When the automation script is tightly coupled with tool technology, then situation would be worst since switching to a different tool will result into whole lot of past efforts getting scrapped.
===Need for a Unified solution===
An automation engineer is required to support diverse applications. If each project implements a unique test strategy, then engineer moving among different projects can potentially be more a hindrance rather than a help. The time needed for the tester to become productive in the new environment just may not be there. And, it may surely detract from the productivity of those bringing the new tester up to speed.
===Language dependency with tools===
All of the automation tools uses some scripting language. Most unfortunate of all, even fully capable testers are seldom given the time required to gain the appropriate software development skills. For the most part, testers have been testers, not programmers. Consequently, the ‘simple’ commercial solutions have been far too complex to implement and maintain; and they become shelf-ware.
===Need of Modular approach===
Ground requirement of an automation system goes hands in hands with the capability of modularizing various components of a test cycle. i.e. need for linking simple functional blocks to create more complex scenarios. Automation tools rarely provide help for modularization. When same is expected from the tool supported language and that too from a tester the maintainability is always compromised.
===Intermixing of Application business logic with Tools complexity===
When a testing team is required to automate an applications testing process, very often a tester lands up in creating a wrapper on top of a privileged automation tool. Many times the wrapper is termed as a framework, which is definitely a misnomer.  The tools complexity and the applications business logics are so much inter-weaved that for a new automation engineer or even for the same test engineer looking at the script after a period of time, it becomes hard to figure out the functional goal of the script.
===Intermixing of Data with the Application logic===
Each engineer has their own way of looking into a requirement. When it comes to automation, a team may find varying solution to achieve same functional aspect. What should go as data and what should be the plain logic is individual’s perception. In absence of a regulating framework there always remains a scope of mixing the data with the application logic. As a result of which there will be increased maintenance cost , though not visible at early phase of scripting.